# CS-230-Operating-Platforms
The Gaming Room is a client looking to expand their existing game, Draw It or Lose It, into a cross-platform application that can work seamlessly on web, desktop, and mobile devices. Their key requirement was a scalable, secure, and responsive game that could manage and render a large library of high-resolution images while supporting multiplayer interaction and real-time updates. They wanted the system to be efficient in both memory and storage usage, capable of running reliably across various environments, and flexible enough to support distributed communication between platforms.

One thing I think I did particularly well was breaking down the complex technical requirements into smaller, manageable parts within the design document. By focusing on the specific needs of each system component, such as memory management, storage allocation, and distributed architecture. I was able to propose practical solutions that aligned with both the business goals and technical constraints. This helped me stay organized and made the documentation clear and easy to follow.

Working through the software design document before jumping into code was extremely helpful. It forced me to slow down and think critically about how each part of the system would work together. For example, outlining how the operating platform would manage memory and storage gave me a clear roadmap when writing or planning any future code. It also helped me anticipate potential issues, like how to handle communication between platforms or ensure data security.

If I had the chance to revise one part of my work, I would spend more time fleshing out the security section. While I did include basic strategies for protecting user data and securing connections between systems, I think I could’ve gone deeper into encryption protocols or secure authentication methods across platforms. This would have added another layer of value to the design.

Understanding the user’s needs was key to shaping every part of this project. For instance, knowing the game had to run smoothly with rapid image rendering meant I had to factor in fast memory access and optimized storage. Considering user experience helped ensure the game would be playable and enjoyable on any device. If the design ignored these needs, the final product could be slow, glitchy, or frustrating to use.

When it comes to designing software, I’ve learned that taking a layered approach, starting with understanding the problem, mapping out the architecture, and documenting everything clearly, makes development much smoother. In the future, I’ll continue to use design templates, UML diagrams, and structured requirement breakdowns to analyze and design software. It’s a method that not only helps with planning but also sets up the project for long-term success.
